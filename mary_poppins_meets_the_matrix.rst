Mary Poppins Meets The Matrix
=============================

:author: Bruce Tate <bruce@rapidred.com>


#. Languages

  * Ruby
  * Io
  * Prolog
  * Scala
  * Haskell
  * Erlang
  * Clojure

#. Prolog

  * "Rain Man"
  * 1972
  * AI language
  * Foundation of Erlang
  * Solved Sudoku problem in a couple hours
  * Describe the rules/problem, not how to find the solution.

#. Erlang

  * "Agent Smith"
  * Joe Armstrong rejected OO due to mutable state/shared state.
  * Distributed, fault-tolerant, Hot swap
  * Problem: Russian Roulette
  * Use lightweight processes for everything

#. Haskell

  * "Spock"
  * Logic heavy
  * Inverts hard & easy
  * Purely functional
  * Static typing
  * Lazy Fibonacci Example
  * Composable Typing (& Optional)
  * Heavy use of Currying

#. Ruby

  * "Mary Poppins"
  * Metaprogramming-heavy
  * Everything is mutable
  * Matz was trying to improve programmer, not program, performance
  * Problem: Metaprogramming

#. Scala

  * "Edward Scissorhands"
  * Bridge language between OO & functional
  * Every time there's a paradigm change, new bridge languages spring up
  * Actors
  * Problem: Internet Word Counter

#. Io

  * "Ferris Bueller"
  * Prototype based
  * Message-passing
  * Chaining
  * "Prototype Operator Prototype" is the only syntactic sugar
  * Fix things after the fact, reach back into sender and change the value
  * Gets concurrency right
  
    * Actors, Messages, Coroutines, Immutability
  
  * Simple syntax & metaprogramming
  * Small footprint (great for embedded systems)
  * Problem: Simple cache & internet page manipulation

#. Clojure

  * "Yoda"
  * Old & wise yet "Exile" (Lisp)
  * Portability & community (Java)
  * Problem: Worker Queue

#. Prolog is brute-force but has optimizations to constrain the problem set
#. Favorites:

  * Ruby
  * Haskell
  * Constructs: List Comprehensions (HA!)

#. Languages That Barely Missed The Cut

  * Python (Didn't want another OO)
  * Javascript (Good things but messy)
  * Lua
  * Factor (only due to interest)
